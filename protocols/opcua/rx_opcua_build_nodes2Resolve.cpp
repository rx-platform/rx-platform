
/****************************************************************************
* This file is automatically generated by <opcgen-nodes> tool
*
* Generated at:6/17/2022 10:56 AM
*
****************************************************************************/


#include "pch.h"
#include "rx_opcua_build_nodes2.h"

namespace protocols {
namespace opcua {
namespace opcua_addr_space {


const uintptr_t valued_idx_mask = 0x80000000;
const uintptr_t idx_value_mask = 0x0fffffff;
const uintptr_t invalid_idx = 0xffffffff;

rx_result opcua_std_address_space_builder::resolve_references_collection(node_references::references_type& col, opcua_std_address_space& server)
{
	for (auto& one_ref : col)
	{
		uintptr_t converted = (uintptr_t)one_ref.resolved_node;
		if (converted == invalid_idx)
		{
			one_ref.resolved_node = nullptr;
		}
		else if (converted & valued_idx_mask)
		{
			converted &= idx_value_mask;
			RX_ASSERT(converted < server.registered_valued_nodes_.size());
			one_ref.resolved_node = &server.registered_valued_nodes_[converted];
		}
		else
		{
			RX_ASSERT(converted < server.registered_nodes_.size());
			one_ref.resolved_node = &server.registered_nodes_[converted];
		}
	}
	return true;
}

rx_result opcua_std_address_space_builder::resolve_standard_address_space_references(opcua_std_address_space& server)
{
	for (auto& one : server.registered_nodes_)
	{
		auto result = resolve_references_collection(one.references_.references, server);
		if (!result)
			return result;
		result = resolve_references_collection(one.references_.inverse_references, server);
		if (!result)
			return result;
	}
	for (auto& one : server.registered_valued_nodes_)
	{
		auto result = resolve_references_collection(one.references_.references, server);
		if (!result)
			return result;
		result = resolve_references_collection(one.references_.inverse_references, server);
		if (!result)
			return result;
	}
	return true;
} // resolve_standard_address_space_References

} //namespace protocols
} //namespace opcua
} //namespace opcua_addr_space

